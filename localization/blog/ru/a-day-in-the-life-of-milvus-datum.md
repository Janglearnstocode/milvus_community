---
id: a-day-in-the-life-of-milvus-datum.md
title: Один день из жизни Milvus Datum
author: 'Stefan Webb, Anthony Tu'
date: 2025-03-17T00:00:00.000Z
desc: 'Итак, давайте прогуляемся по одному дню из жизни Дэйва, дателя Милвуса.'
cover: assets.zilliz.com/a_day_in_the_life_of_a_milvus_datum_ca279f7f59.png
tag: Engineering
tags: 'Deep Research, open source AI, Milvus, LangChain, DeepSeek R1'
recommend: true
canonicalUrl: 'https://milvus.io/blog/a-day-in-the-life-of-milvus-datum.md'
---
<p>Создание такой производительной <a href="https://zilliz.com/learn/what-is-vector-database">векторной базы данных</a>, как Milvus, масштабируемой до миллиардов векторов и обрабатывающей веб-трафик, - непростая задача. Это требует тщательного, интеллектуального проектирования распределенной системы. При этом неизбежен компромисс между производительностью и простотой внутреннего устройства такой системы.</p>
<p>Несмотря на то что мы старались хорошо сбалансировать этот компромисс, некоторые аспекты внутреннего устройства оставались непрозрачными. Эта статья призвана развеять все тайны о том, как Milvus разделяет вставку, индексирование и обслуживание данных на узлах. Понимание этих процессов на высоком уровне необходимо для эффективной оптимизации производительности запросов, стабильности системы и отладки проблем.</p>
<p>Итак, давайте посмотрим на один день из жизни Дэйва, базы данных Milvus. Представьте, что вы вставляете Дэйва в свою коллекцию в <a href="https://milvus.io/docs/install-overview.md#Milvus-Distributed">Milvus Distributed deployment</a> (см. схему ниже). С вашей точки зрения, он попадает непосредственно в коллекцию. Однако за кулисами происходит множество шагов в независимых подсистемах.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/a_day_in_the_life_of_a_milvus_datum_ca279f7f59.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Proxy-Nodes-and-the-Message-Queue" class="common-anchor-header">Прокси-узлы и очередь сообщений<button data-href="#Proxy-Nodes-and-the-Message-Queue" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Proxy_Nodes_and_the_Message_Queue_03a0fde0c5.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Сначала вы вызываете объект MilvusClient, например, через библиотеку PyMilvus, и отправляете запрос <code translate="no">_insert()</code>_ на <em>прокси-узел</em>. Прокси-узлы являются шлюзом между пользователем и системой баз данных, выполняя такие операции, как балансировка нагрузки на входящий трафик и сопоставление нескольких результатов перед их возвратом пользователю.</p>
<p>Чтобы определить, в какой <em>канал</em> отправить элемент, к его первичному ключу применяется хэш-функция. Каналы, реализованные с помощью тем Pulsar или Kafka, представляют собой хранилище потоковых данных, которые затем могут быть отправлены подписчикам канала.</p>
<h2 id="Data-Nodes-Segments-and-Chunks" class="common-anchor-header">Узлы, сегменты и куски данных<button data-href="#Data-Nodes-Segments-and-Chunks" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Data_Nodes_Segments_and_Chunks_ae122dd1ac.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>После того как данные были отправлены в соответствующий канал, канал отправляет их в соответствующий сегмент <em>узла данных</em>. Узлы данных отвечают за хранение и управление буферами данных, называемыми <em>растущими сегментами</em>. На каждый осколок приходится один растущий сегмент.</p>
<p>По мере вставки данных в сегмент он увеличивается до максимального размера, по умолчанию равного 122 МБ. В это время меньшие части сегмента, по умолчанию 16 МБ, называемые <em>чанками</em>, перемещаются в постоянное хранилище, например, в S3 от AWS или другое совместимое хранилище, такое как MinIO. Каждый чанк представляет собой физический файл в объектном хранилище, и для каждого поля существует отдельный файл. Смотрите рисунок выше, иллюстрирующий иерархию файлов в объектном хранилище.</p>
<p>Таким образом, данные коллекции распределяются по узлам данных, внутри которых они разбиваются на сегменты для буферизации, которые далее разбиваются на чанки для каждого поля для постоянного хранения. На двух диаграммах выше это показано более наглядно. Разделяя входящие данные таким образом, мы полностью используем параллелизм кластера в отношении пропускной способности сети, вычислений и хранения.</p>
<h2 id="Sealing-Merging-and-Compacting-Segments" class="common-anchor-header">Уплотнение, объединение и сжатие сегментов<button data-href="#Sealing-Merging-and-Compacting-Segments" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Sealing_Merging_and_Compacting_Segments_d5a6a37261.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Итак, мы рассказали историю о том, как наш дружелюбный датамент Дэйв проходит путь от запроса <code translate="no">_insert()</code>_ до постоянного хранилища. Конечно, его история на этом не заканчивается. Существуют дальнейшие шаги, позволяющие сделать процесс поиска и индексирования более эффективным. Управляя размером и количеством сегментов, система в полной мере использует параллелизм кластера.</p>
<p>Как только сегмент достигает максимального размера на узле данных, по умолчанию 122 МБ, он считается <em>закрытым</em>. Это означает, что буфер на узле данных очищается, чтобы освободить место для нового сегмента, а соответствующие чанки в постоянном хранилище помечаются как принадлежащие закрытому сегменту.</p>
<p>Узлы данных периодически ищут более мелкие закрытые сегменты и объединяют их в более крупные, пока не достигнут максимального размера в 1 ГБ (по умолчанию) на сегмент. Напомним, что когда элемент удаляется в Milvus, он просто помечается флагом удаления - считайте это "Смертельной гонкой" для Дэйва. Когда количество удаленных элементов в сегменте превышает заданный порог, по умолчанию 20 %, сегмент уменьшается в размере - эту операцию мы называем <em>уплотнением</em>.</p>
<p>Индексирование и поиск в сегментах</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Indexing_and_Searching_through_Segments_478c0067be.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Indexing_and_Searching_through_Segments_1_0c31b5a340.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Существует дополнительный тип узла, <em>индексный узел</em>, который отвечает за создание индексов для запечатанных сегментов. Когда сегмент запечатан, узел данных отправляет запрос на индексный узел для построения индекса. Затем индексный узел отправляет готовый индекс в хранилище объектов. Каждый запечатанный сегмент имеет свой собственный индекс, хранящийся в отдельном файле. Вы можете просмотреть этот файл вручную, обратившись к ведру - иерархия файлов показана на рисунке выше.</p>
<p>Узлы запросов - не только узлы данных - подписываются на темы очереди сообщений для соответствующих шардов. Растущие сегменты реплицируются на узлах запросов, и узел по мере необходимости загружает в память запечатанные сегменты, принадлежащие коллекции. Он строит индекс для каждого растущего сегмента по мере поступления данных и загружает окончательно сформированные индексы для запечатанных сегментов из хранилища данных.</p>
<p>Представьте себе, что вы вызываете объект MilvusClient с запросом <em>search()</em>, который охватывает Дэйва. После того как запрос будет направлен на все узлы запроса через прокси-узел, каждый узел запроса выполняет поиск по векторному сходству (или другой метод поиска, например запрос, поиск по диапазону или поиск по группировке), перебирая сегменты один за другим. Результаты объединяются на всех узлах в MapReduce и отправляются обратно пользователю, а Дэйв радуется, что наконец-то воссоединился с вами.</p>
<h2 id="Discussion" class="common-anchor-header">Обсуждение<button data-href="#Discussion" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Мы рассказали об одном дне из жизни Дейва-датчика, как для операций <code translate="no">_insert()</code>_, так и для <code translate="no">_search()</code>_. Другие операции, такие как <code translate="no">_delete()</code>_ и <code translate="no">_upsert()</code>_, работают аналогично. Нам неизбежно пришлось упростить обсуждение и опустить более мелкие детали. Однако в целом вы должны иметь достаточное представление о том, как Milvus спроектирован для параллелизма между узлами распределенной системы, чтобы быть надежным и эффективным, и как вы можете использовать это для оптимизации и отладки.</p>
<p><em>Важный вывод из этой статьи: Milvus спроектирован с учетом разделения задач между типами узлов. Каждый тип узла выполняет определенную, взаимоисключающую функцию, а хранение и вычисления разделены.</em> В результате каждый компонент можно масштабировать независимо друг от друга, настраивая параметры в зависимости от сценария использования и трафика. Например, можно масштабировать количество узлов запросов для обслуживания возросшего трафика без масштабирования узлов данных и индексов. Благодаря такой гибкости пользователи Milvus обрабатывают миллиарды векторов и обслуживают веб-трафик с задержкой запросов менее 100 мс.</p>
<p>Вы также можете воспользоваться преимуществами распределенного дизайна Milvus, даже не развертывая распределенный кластер, с помощью <a href="https://zilliz.com/cloud">Zilliz Cloud</a>, полностью управляемого сервиса Milvus. <a href="https://cloud.zilliz.com/signup">Зарегистрируйтесь сегодня на бесплатный уровень Zilliz Cloud и начните использовать Дэйва в действии!</a></p>
