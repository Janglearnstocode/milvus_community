---
id: benchmarks-lie-vector-dbs-deserve-a-real-test.md
title: المعايير تكذب - ناقلات قواعد البيانات المتجهة تستحق اختبارًا حقيقيًا
author: Min Tian
date: 2025-05-14T00:00:00.000Z
desc: >-
  اكتشف فجوة الأداء في قواعد البيانات المتجهة باستخدام VDBBench. تختبر أداتنا في
  ظل سيناريوهات إنتاج حقيقية، مما يضمن تشغيل تطبيقات الذكاء الاصطناعي الخاصة بك
  بسلاسة دون توقف غير متوقع.
cover: >-
  assets.zilliz.com/Benchmarks_Lie_Vector_D_Bs_Deserve_a_Real_Test_9280c66efc.png
tag: Engineering
recommend: true
publishToMedium: true
tags: 'Milvus, vector database, vector search, AI Agents, LLM'
meta_keywords: >-
  Vector database, vectordbbench, vector database benchmark, vector search
  performance
meta_title: |
  Benchmarks Lie — Vector DBs Deserve a Real Test
origin: 'https://milvus.io/blog/benchmarks-lie-vector-dbs-deserve-a-real-test.md'
---
<h2 id="The-Vector-Database-You-Chose-Based-on-Benchmarks-Might-Fail-in-Production" class="common-anchor-header">قد تفشل قاعدة البيانات المتجهة التي اخترتها بناءً على المعايير القياسية في الإنتاج<button data-href="#The-Vector-Database-You-Chose-Based-on-Benchmarks-Might-Fail-in-Production" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>عند اختيار <a href="https://milvus.io/blog/what-is-a-vector-database.md">قاعدة بيانات مت</a> جهة لتطبيق الذكاء الاصطناعي الخاص بك، فإن المعايير التقليدية تشبه اختبار قيادة سيارة رياضية على مسار فارغ، لتجد أنها تتوقف في ساعة الذروة. الحقيقة غير المريحة؟ لا تقيّم معظم المعايير القياسية الأداء إلا في ظروف مصطنعة لا توجد أبدًا في بيئات الإنتاج.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Benchmarks_Lie_Vector_D_Bs_Deserve_a_Real_Test_9280c66efc.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>معظم المعايير القياسية تختبر قواعد البيانات المتجهة <strong>بعد</strong> استيعاب جميع البيانات وبناء الفهرس بالكامل. ولكن في الإنتاج، لا تتوقف البيانات عن التدفق أبدًا. لا يمكنك إيقاف نظامك لساعات لإعادة بناء الفهرس.</p>
<p>لقد رأينا الانفصال بشكل مباشر. على سبيل المثال، قد يتباهى Elasticsearch بسرعات استعلام على مستوى أجزاء من الثانية، ولكن خلف الكواليس، شاهدنا أنه يستغرق <strong>أكثر من 20 ساعة</strong> فقط لتحسين فهرسه. هذا وقت تعطل لا يستطيع أي نظام إنتاج تحمله، خاصة في أعباء عمل الذكاء الاصطناعي التي تتطلب تحديثات مستمرة واستجابات فورية.</p>
<p>مع Milvus، بعد إجراء عدد لا يحصى من تقييمات إثبات المفهوم (PoC) مع عملاء المؤسسات، اكتشفنا نمطًا مقلقًا: <strong>قواعد البيانات المتجهة التي تتفوق في البيئات المعملية الخاضعة للرقابة غالبًا ما تعاني في ظل أحمال الإنتاج الفعلية.</strong> هذه الفجوة الحرجة لا تحبط مهندسي البنية التحتية فحسب، بل يمكن أن تعرقل مبادرات الذكاء الاصطناعي بأكملها المبنية على وعود الأداء المضللة هذه.</p>
<p>لهذا السبب قمنا ببناء <a href="https://github.com/zilliztech/VectorDBBench">VDBBench</a>: معيار مفتوح المصدر مصمم من الألف إلى الياء لمحاكاة واقع الإنتاج. على عكس الاختبارات الاصطناعية التي تختار سيناريوهات منتقاة بعناية، يقوم VDBBench بدفع قواعد البيانات من خلال الاستيعاب المستمر، وظروف التصفية الصارمة، والسيناريوهات المتنوعة، تمامًا مثل أعباء عمل الإنتاج الفعلية. مهمتنا بسيطة: تزويد المهندسين بأداة تُظهر كيفية أداء قواعد البيانات المتجهة فعليًا في ظل ظروف العالم الحقيقي حتى تتمكن من اتخاذ قرارات البنية التحتية بناءً على أرقام جديرة بالثقة.</p>
<h2 id="The-Gap-between-Benchmarks-and-Reality" class="common-anchor-header">الفجوة بين المقاييس المعيارية والواقع<button data-href="#The-Gap-between-Benchmarks-and-Reality" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تعاني مناهج القياس المعيارية التقليدية من ثلاثة عيوب حرجة تجعل نتائجها بلا معنى عمليًا لاتخاذ قرارات الإنتاج:</p>
<h3 id="1-Outdated-Data" class="common-anchor-header">1. البيانات القديمة</h3><p>لا تزال العديد من المقاييس المعيارية تعتمد على مجموعات بيانات قديمة مثل SIFT أو<a href="https://zilliz.com/glossary/glove"> GloVe،</a> والتي لا تشبه كثيراً مجموعات البيانات المعقدة عالية الأبعاد التي تولدها نماذج الذكاء الاصطناعي اليوم. خذ هذا بعين الاعتبار: يحتوي SIFT على متجهات ذات 128 بُعداً، في حين أن التضمينات الشائعة من نماذج التضمين الخاصة ب OpenAI تتراوح أبعادها بين 768 و3072 بُعداً.</p>
<h3 id="2-Vanity-Metrics" class="common-anchor-header">2. مقاييس الغرور</h3><p>تركز العديد من المقاييس القياسية فقط على متوسط زمن الاستجابة أو ذروة سرعة الاستجابة في الثانية، مما يخلق صورة مشوهة. تفشل هذه المقاييس المثالية في التقاط القيم المتطرفة والتناقضات التي يواجهها المستخدمون الفعليون في بيئات الإنتاج. على سبيل المثال، ما فائدة الرقم المثير للإعجاب في سرعة الاستجابة في الثانية إذا كان يتطلب موارد حسابية غير محدودة من شأنها أن تفلس مؤسستك؟</p>
<h3 id="3-Oversimplified-Scenarios" class="common-anchor-header">3. سيناريوهات مفرطة التبسيط</h3><p>تختبر معظم المقاييس القياسية أعباء العمل الأساسية الثابتة فقط - أي "مرحبًا بالعالم" في البحث المتجه. على سبيل المثال، لا تصدر طلبات البحث إلا بعد استيعاب مجموعة البيانات بأكملها وفهرستها، متجاهلةً الواقع الديناميكي الذي يبحث فيه المستخدمون أثناء تدفق البيانات الجديدة. يتجاهل هذا التصميم التبسيطي الأنماط المعقدة التي تحدد أنظمة الإنتاج الحقيقية مثل الاستعلامات المتزامنة وعمليات البحث المصفاة والاستيعاب المستمر للبيانات.</p>
<p>وإدراكًا منا لهذه العيوب، أدركنا أن الصناعة بحاجة إلى <strong>تحول جذري في فلسفة القياس المعياري - وهو تحول</strong>يرتكز على كيفية تصرف أنظمة الذكاء الاصطناعي في الواقع في البرية. لهذا السبب قمنا ببناء <a href="https://github.com/zilliztech/VectorDBBench">VDBBench</a>.</p>
<h2 id="From-Lab-to-Production-How-VDBBench-Bridges-the-Gap" class="common-anchor-header">من المختبر إلى الإنتاج: كيف يعمل VDBBench على سد الفجوة<button data-href="#From-Lab-to-Production-How-VDBBench-Bridges-the-Gap" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>لا يكتفي VDBBBBench بتكرار فلسفات القياس التي عفا عليها الزمن - بل يعيد بناء المفهوم من المبادئ الأولى مع اعتقاد واحد: <strong>المعيار لا يكون ذا قيمة إلا إذا كان يتنبأ بسلوك الإنتاج الفعلي</strong>.</p>
<p>لقد صممنا VDBBench لمحاكاة ظروف العالم الحقيقي بأمانة عبر ثلاثة أبعاد مهمة: أصالة البيانات، وأنماط عبء العمل، وقياس الأداء.</p>
<h3 id="Modernizing-the-Dataset" class="common-anchor-header">تحديث مجموعة البيانات</h3><p>لقد قمنا بإصلاح شامل لمجموعات البيانات المستخدمة في قياس أداء VDBBB. فبدلاً من مجموعات الاختبار القديمة مثل SIFT و GloVe، يستخدم VDBBench متجهات تم إنشاؤها من أحدث نماذج التضمين التي تشغل تطبيقات الذكاء الاصطناعي اليوم.</p>
<p>ولضمان الملاءمة، خاصةً بالنسبة لحالات الاستخدام مثل التوليد المعزز للاسترجاع (RAG)، اخترنا مجموعات تعكس سيناريوهات المؤسسات في العالم الحقيقي والسيناريوهات الخاصة بالمجال. وتتراوح هذه من قواعد المعرفة ذات الأغراض العامة إلى التطبيقات الرأسية مثل الإجابة عن الأسئلة الطبية الحيوية والبحث على نطاق واسع على الويب.</p>
<table>
<thead>
<tr><th></th><th></th><th></th><th></th></tr>
</thead>
<tbody>
<tr><td><strong>المجموعة</strong></td><td><strong>نموذج التضمين</strong></td><td><strong>الأبعاد</strong></td><td><strong>الحجم</strong></td></tr>
<tr><td>ويكيبيديا</td><td>كوهير V2</td><td>768</td><td>1M / 10M</td></tr>
<tr><td>بيواسكو</td><td>كوهير V3</td><td>1024</td><td>1M / 10M</td></tr>
<tr><td>C4</td><td>OpenAI</td><td>1536</td><td>500 ألف / 5 مليون</td></tr>
<tr><td>MSMarco V2</td><td>udever-bloom-1b1</td><td>1536</td><td>1 م / 10 م / 138 م</td></tr>
</tbody>
</table>
<p>الجدول: مجموعات البيانات المستخدمة في VDBBench</p>
<p>يدعم VDBBench أيضًا مجموعات البيانات المخصصة، مما يتيح لك القياس باستخدام بياناتك الخاصة التي تم إنشاؤها من نماذج التضمين الخاصة بك لأعباء العمل الخاصة بك. في النهاية، لا توجد مجموعة بيانات تحكي قصة أفضل من بيانات الإنتاج الخاصة بك.</p>
<h3 id="Production-Focused-Metric-Design" class="common-anchor-header">تصميم متري يركز على الإنتاج</h3><p><strong>يعطي VDBBench الأولوية للمقاييس التي تعكس الأداء في العالم الحقيقي، وليس فقط النتائج المعملية.</strong> لقد أعدنا تصميم القياس حول ما هو مهم بالفعل في بيئات الإنتاج: الموثوقية تحت الحمل، والكمون المتتابع، والإنتاجية المستدامة، والدقة.</p>
<ul>
<li><p><strong>الكمون P95/P99 لقياس تجربة المستخدم الحقيقية</strong>: يخفي متوسط/متوسط زمن الكمون القيم المتطرفة التي تحبط المستخدمين الحقيقيين. هذا هو السبب في أن VDBBench يركز على زمن كمون الذيل مثل P95/P99، مما يكشف عن الأداء الذي سيحققه 95% أو 99% من استفساراتك بالفعل.</p></li>
<li><p><strong>الإنتاجية المستدامة تحت الحمل:</strong> النظام الذي يؤدي أداءً جيدًا لمدة 5 ثوانٍ لا يفي بالغرض في الإنتاج. يعمل VDBBench على زيادة التزامن تدريجيًا للعثور على الحد الأقصى المستدام لقاعدة بياناتك من الاستعلامات في الثانية (<code translate="no">max_qps</code>) - وليس رقم الذروة في ظل ظروف قصيرة ومثالية. هذا يوضح مدى قدرة نظامك على الصمود مع مرور الوقت.</p></li>
<li><p><strong>التذكر متوازن مع الأداء:</strong> السرعة بدون دقة لا معنى لها. يتم إقران كل رقم أداء في VDBBench مع الاستدعاء، حتى تعرف بالضبط مقدار الأهمية التي تستبدلها بالإنتاجية. يتيح ذلك إمكانية إجراء مقارنات عادلة ومتكافئة بين الأنظمة ذات المفاضلات الداخلية المختلفة إلى حد كبير.</p></li>
</ul>
<h3 id="Test-Methodology-That-Reflects-Reality" class="common-anchor-header">منهجية اختبار تعكس الواقع</h3><p>يتمثل أحد الابتكارات الرئيسية في تصميم VDBBench في <strong>الفصل بين الاختبار التسلسلي والمتزامن،</strong> مما يساعد على التقاط كيفية تصرف الأنظمة تحت أنواع مختلفة من الأحمال. على سبيل المثال، تنقسم مقاييس الكمون على النحو التالي:</p>
<ul>
<li><p><code translate="no">serial_latency_p99</code> يقيس أداء النظام في ظل الحد الأدنى من التحميل، حيث تتم معالجة طلب واحد فقط في كل مرة. يمثل هذا <em>أفضل سيناريو</em> لوقت الاستجابة.</p></li>
<li><p><code translate="no">conc_latency_p99</code> يلتقط سلوك النظام في ظل <em>ظروف واقعية عالية التواتر،</em> حيث تصل طلبات متعددة في وقت واحد.</p></li>
</ul>
<h3 id="Two-Benchmark-Phases" class="common-anchor-header">مرحلتان معياريتان</h3><p>يقسم VDBBench الاختبار إلى مرحلتين حاسمتين:</p>
<ol>
<li><strong>الاختبار التسلسلي</strong></li>
</ol>
<p>هذا هو تشغيل عملية واحدة من 1,000 استعلام. تؤسس هذه المرحلة خط أساس للأداء والدقة المثاليين، وتبلغ عن كل من <code translate="no">serial_latency_p99</code> والاستدعاء.</p>
<ol start="2">
<li><strong>اختبار التزامن</strong></li>
</ol>
<p>تحاكي هذه المرحلة بيئة إنتاج تحت حمل مستدام.</p>
<ul>
<li><p><strong>محاكاة واقعية للعميل</strong>: تعمل كل عملية اختبار بشكل مستقل مع اتصالها الخاص ومجموعة الاستعلامات الخاصة بها. هذا يتجنب تداخل الحالة المشتركة (على سبيل المثال، ذاكرة التخزين المؤقت) التي يمكن أن تشوه النتائج.</p></li>
<li><p><strong>بدء متزامن</strong>: تبدأ جميع العمليات في وقت واحد، مما يضمن أن تعكس QPS المقاسة بدقة مستوى التزامن المزعوم.</p></li>
</ul>
<p>تضمن هذه الأساليب المنظمة بعناية أن تكون القيم <code translate="no">max_qps</code> و <code translate="no">conc_latency_p99</code> التي أبلغ عنها VDBBench <strong>دقيقة وذات صلة بالإنتاج،</strong> مما يوفر رؤى مفيدة لتخطيط سعة الإنتاج وتصميم النظام.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Latency_of_Milvus_16c64g_standalone_at_Varying_Concurrency_Levels_Cohere_1_M_Test_7f2294e87a.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>الشكل: QPS والكمون لـ Milvus-16c64g-standalone عند مستويات متفاوتة من التزامن (اختبار Cohere 1M). في هذا الاختبار، لا يتم استخدام Milvus في البداية بشكل كافٍ حتى</em> <strong><em>مستوى التزامن</em></strong><em> 20، وتؤدي زيادة التزامن إلى تحسين استخدام النظام وتؤدي إلى زيادة QPS. بعد</em> <strong><em>مستوى التزامن</em></strong><em> 20، يصل النظام إلى الحمل الكامل: لا تؤدي الزيادات الإضافية في التزامن إلى تحسين الإنتاجية، ويرتفع زمن الاستجابة بسبب التأخير في الانتظار.</em></p>
<h2 id="Beyond-Searching-Static-Data-The-Real-Production-Scenarios" class="common-anchor-header">ما بعد البحث في البيانات الثابتة: سيناريوهات الإنتاج الحقيقي<button data-href="#Beyond-Searching-Static-Data-The-Real-Production-Scenarios" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>على حد علمنا، فإن VDBBench هي الأداة المعيارية الوحيدة التي تختبر قواعد البيانات المتجهة عبر مجموعة كاملة من سيناريوهات الإنتاج الحرجة، بما في ذلك التجميع الثابت والتصفية وحالات التدفق.</p>
<h3 id="Static-Collection" class="common-anchor-header">التجميع الثابت</h3><p>على عكس المقاييس الأخرى التي تتسرع في الاختبار، يضمن VDBBench أولاً أن كل قاعدة بيانات قد حسّنت فهارسها بالكامل - وهو شرط أساسي بالغ الأهمية للإنتاج غالبًا ما تتجاهله العديد من المقاييس. هذا يعطيك الصورة الكاملة:</p>
<ul>
<li><p>وقت استيعاب البيانات</p></li>
<li><p>وقت الفهرسة (الوقت المستخدم لبناء فهرس محسّن، والذي يؤثر بشكل كبير على أداء البحث)</p></li>
<li><p>أداء البحث على الفهارس المحسّنة بالكامل في ظل الظروف التسلسلية والمتزامنة</p></li>
</ul>
<h3 id="Filtering" class="common-anchor-header">التصفية</h3><p>نادرًا ما يحدث البحث المتجه في الإنتاج بمعزل عن غيره. فالتطبيقات الحقيقية تجمع بين تشابه المتجهات وتصفية البيانات الوصفية ("ابحث عن الأحذية التي تشبه هذه الصورة ولكن تكلفتها أقل من 100 دولار"). هذا البحث المتجه المصفى يخلق تحديات فريدة من نوعها:</p>
<ul>
<li><p><strong>تعقيد التصفية</strong>: المزيد من الأعمدة القياسية والشروط المنطقية تزيد من المتطلبات الحسابية</p></li>
<li><p><strong>انتقائية</strong> التصفية: تكشف <a href="https://milvus.io/blog/how-to-filter-efficiently-without-killing-recall.md">تجربة الإنتاج لدينا</a> عن هذا الأمر باعتباره القاتل الخفي للأداء - يمكن أن تتقلب سرعات الاستعلام بأوامر من حيث الحجم اعتمادًا على مدى انتقائية المرشحات</p></li>
</ul>
<p>يقوم VDBBench بتقييم أداء المرشحات بشكل منهجي عبر مستويات انتقائية متفاوتة (من 50% إلى 99.9%)، مما يوفر ملفًا شاملاً لكيفية تعامل قواعد البيانات مع هذا النمط الإنتاجي المهم.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Recall_of_Milvus_and_Open_Search_Across_Different_Filter_Selectivity_Levels_Cohere_1_M_Test_4b5df2244d.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>الشكل: QPS واستدعاء Milvus وOpenSearch عبر مستويات انتقائية مختلفة للمرشح (اختبار Cohere 1M). يمثل المحور X النسبة المئوية للبيانات التي تمت تصفيتها. كما هو موضح، يحافظ برنامج Milvus على نسبة استرجاع عالية باستمرار عبر جميع مستويات انتقائية التصفية، بينما يُظهر OpenSearch أداءً غير مستقر، مع تذبذب الاسترجاع بشكل كبير في ظل ظروف التصفية المختلفة.</em></p>
<h3 id="Streaming" class="common-anchor-header">التدفق</h3><p>نادرًا ما تتمتع أنظمة الإنتاج برفاهية البيانات الثابتة. حيث تتدفق المعلومات الجديدة باستمرار أثناء تنفيذ عمليات البحث - وهو سيناريو تنهار فيه العديد من قواعد البيانات المثيرة للإعجاب.</p>
<p>تفحص حالة اختبار التدفق الفريد من نوعه لـ VDBBench أداء البحث أثناء الإدراج، وتقيس</p>
<ol>
<li><p><strong>تأثير تزايد حجم البيانات</strong>: كيف يتوسع أداء البحث مع زيادة حجم البيانات.</p></li>
<li><p><strong>تأثير عبء الكتابة</strong>: كيف تؤثر عمليات الكتابة المتزامنة على زمن انتقال البحث والإنتاجية، حيث تستهلك الكتابة أيضًا موارد وحدة المعالجة المركزية أو الذاكرة في النظام.</p></li>
</ol>
<p>تمثل سيناريوهات التدفق اختبار إجهاد شامل لأي قاعدة بيانات متجهة. لكن بناء معيار <em>عادل</em> لهذا ليس بالأمر الهيّن. لا يكفي وصف كيف يتصرف نظام واحد - نحن بحاجة إلى نموذج تقييم متسق يتيح <strong>إجراء مقارنات بين</strong> قواعد البيانات المختلفة.</p>
<p>بالاعتماد على خبرتنا في مساعدة الشركات في عمليات النشر في العالم الحقيقي، قمنا ببناء نهج منظم وقابل للتكرار. مع VDBBench:</p>
<ul>
<li><p>يمكنك <strong>تحديد معدل إدخال ثابت</strong> يعكس عبء عمل الإنتاج المستهدف.</p></li>
<li><p>ثم يطبق VDBBench بعد ذلك <strong>ضغط تحميل متطابق</strong> عبر جميع الأنظمة، مما يضمن أن تكون نتائج الأداء قابلة للمقارنة مباشرةً.</p></li>
</ul>
<p>على سبيل المثال، مع مجموعة بيانات Cohere 10Mas وهدف إدخال 500 صف/ثانية:</p>
<ul>
<li><p>يقوم VDBBench بتشغيل 5 عمليات إنتاج متوازية يقوم كل منها بإدخال 100 صف في الثانية.</p></li>
<li><p>بعد استيعاب كل 10% من البيانات، يقوم VDBBench بتشغيل جولة من اختبار البحث في ظل الظروف التسلسلية والمتزامنة.</p></li>
<li><p>يتم تسجيل مقاييس مثل زمن الاستجابة، والكمية في الثانية، والاسترجاع بعد كل مرحلة.</p></li>
</ul>
<p>تكشف هذه المنهجية المضبوطة عن كيفية تطور أداء كل نظام بمرور الوقت وتحت ضغط تشغيلي حقيقي - مما يمنحك الرؤية التي تحتاجها لاتخاذ قرارات البنية التحتية التي تتوسع.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/igure_QPS_and_Recall_of_Pinecone_vs_Elasticsearch_in_the_Cohere_10_M_Streaming_Test_500_rows_s_Ingestion_Rate_548fc02f24.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>الشكل: QPS واستدعاء نظام Pinecone مقابل Elasticsearch في اختبار تدفق Cohere 10M (معدل استيعاب 500 صف/ثانية). حافظت Pinecone على معدل QPS واستدعاء أعلى، حيث أظهرت تحسنًا كبيرًا في QPS بعد إدخال 100% من البيانات.</em></p>
<p>لكن هذه ليست نهاية القصة. يذهب VDBBench إلى أبعد من ذلك من خلال دعم خطوة تحسين اختيارية، مما يسمح للمستخدمين بمقارنة أداء البحث المتدفق قبل تحسين الفهرس وبعده. كما أنه يتتبع ويبلغ عن الوقت الفعلي المستغرق في كل مرحلة، مما يوفر رؤى أعمق حول كفاءة النظام وسلوكه في ظل ظروف شبيهة بالإنتاج.</p>
<p><span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Recall_of_Pinecone_vs_Elasticsearch_in_the_Cohere_10_M_Streaming_Test_After_Optimization_500_rows_s_Ingestion_Rate_d249d290bb.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>الشكل: QPS واستدعاء Pinecone مقابل Elasticsearch في اختبار تدفق Cohere 10M بعد التحسين (معدل استيعاب 500 صف/ثانية)</em></p>
<p>كما هو موضح في الرسم البياني، تفوق ElasticSearch على Pinecone في QPS بعد تحسين الفهرس. معجزة؟ ليس تمامًا. يحكي الرسم البياني الأيمن القصة الكاملة: بمجرد أن يعكس المحور السيني الوقت المنقضي الفعلي، يتضح أن ElasticSearch استغرق وقتًا أطول بكثير للوصول إلى هذا الأداء. وفي الإنتاج، هذا التأخير مهم. تكشف هذه المقارنة عن مفاضلة رئيسية: ذروة الإنتاجية مقابل وقت الخدمة.</p>
<h2 id="Choose-Your-Vector-Database-with-Confidence" class="common-anchor-header">اختر قاعدة بياناتك المتجهة بثقة<button data-href="#Choose-Your-Vector-Database-with-Confidence" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>لا ينبغي أن تكون الفجوة بين النتائج المعيارية والأداء في العالم الحقيقي لعبة تخمين. يوفر VDBBench طريقة لتقييم قواعد البيانات المتجهة في ظل ظروف واقعية شبيهة بالإنتاج، بما في ذلك الاستيعاب المستمر للبيانات وتصفية البيانات الوصفية وأعباء العمل المتدفقة.</p>
<p>إذا كنت تخطط لنشر قاعدة بيانات متجهة في الإنتاج، فإن الأمر يستحق فهم كيفية أدائها بما يتجاوز الاختبارات المعملية المثالية. إن VDBBench مفتوح المصدر وشفاف ومصمم لدعم المقارنات المفيدة والمقارنة بين التطبيقات.</p>
<p>جرب VDBBench مع أعباء العمل الخاصة بك اليوم وشاهد كيف تصمد الأنظمة المختلفة في الممارسة العملية: <a href="https://github.com/zilliztech/VectorDBBench">https://github.com/zilliztech/VectorDBBench.</a></p>
<p>هل لديك أسئلة أو تريد مشاركة نتائجك؟ انضم إلى المحادثة على<a href="https://github.com/zilliztech/VectorDBBench"> GitHub</a> أو تواصل مع مجتمعنا على <a href="https://discord.com/invite/FG6hMJStWu">Discord</a>. نود سماع آرائكم.</p>
