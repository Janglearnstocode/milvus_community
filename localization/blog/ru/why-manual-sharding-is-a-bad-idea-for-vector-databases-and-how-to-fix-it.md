---
id: why-manual-sharding-is-a-bad-idea-for-vector-databases-and-how-to-fix-it.md
title: >-
  Почему ручное шардирование - плохая идея для векторных баз данных и как ее
  исправить
author: James Luan
date: 2025-03-18T00:00:00.000Z
desc: >-
  Узнайте, почему ручное разбиение векторных баз данных создает узкие места и
  как автоматизированное масштабирование Milvus устраняет инженерные накладные
  расходы, обеспечивая плавный рост.
cover: >-
  assets.zilliz.com/Why_Manual_Sharding_is_a_Bad_Idea_for_Vector_Database_And_How_to_Fix_It_1_968a5be504.png
tag: Engineering
tags: 'Milvus, Vector Database, Milvus, AI Infrastructure, Automated Sharding'
recommend: true
canonicalUrl: >-
  https://milvus.io/blog/why-manual-sharding-is-a-bad-idea-for-vector-databases-and-how-to-fix-it.md
---
<p><em>"Изначально мы построили наш семантический поиск на pgvector, а не на Milvus, потому что все наши реляционные данные уже были в PostgreSQL", -</em> вспоминает Алекс, технический директор SaaS-стартапа, специализирующегося на корпоративном искусственном интеллекте. <em>"Но как только мы достигли соответствия продукта рынку, наш рост столкнулся с серьезными препятствиями с инженерной стороны. Быстро стало ясно, что pgvector не рассчитан на масштабируемость. Такие простые задачи, как обновление схемы на нескольких шардах, превратились в утомительные, чреватые ошибками процессы, на которые уходили дни инженерных усилий. Когда мы достигли 100 миллионов векторных вкраплений, задержки запросов стали превышать секунду, что было далеко за пределами допустимого для наших клиентов. После перехода на Milvus работа с шардингом вручную стала казаться нам шагом в каменный век. Жонглировать серверами шардов, словно хрупкими артефактами, - не самое приятное занятие. Ни одна компания не должна это терпеть".</em></p>
<h2 id="A-Common-Challenge-for-AI-Companies" class="common-anchor-header">Общая проблема для компаний, занимающихся разработкой искусственного интеллекта<button data-href="#A-Common-Challenge-for-AI-Companies" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Опыт Алекса не является уникальным для пользователей pgvector. Независимо от того, используете ли вы pgvector, Qdrant, Weaviate или любую другую векторную базу данных, которая полагается на ручной шардинг, проблемы масштабирования остаются одинаковыми. То, что начинается как управляемое решение, быстро превращается в технологический долг по мере роста объемов данных.</p>
<p>Сегодня для стартапов <strong>масштабируемость не является чем-то необязательным - она критически важна</strong>. Это особенно актуально для продуктов ИИ на основе больших языковых моделей (LLM) и векторных баз данных, где скачок от раннего внедрения до экспоненциального роста может произойти в одночасье. Достижение соответствия продукта рынку часто приводит к резкому росту числа пользователей, притоку огромного количества данных и стремительному росту запросов. Но если инфраструктура базы данных не справляется, медленные запросы и неэффективность работы могут затормозить развитие и помешать успеху бизнеса.</p>
<p>Краткосрочное техническое решение может привести к долгосрочным узким местам, заставляя инженерные команды постоянно решать срочные проблемы производительности, сбои баз данных и отказы систем вместо того, чтобы сосредоточиться на инновациях. Наихудший сценарий? Дорогостоящая, требующая много времени перестройка архитектуры базы данных - именно тогда, когда компания должна масштабироваться.</p>
<h2 id="Isn’t-Sharding-a-Natural-Solution-to-Scalability" class="common-anchor-header">Разве шардинг не является естественным решением проблемы масштабируемости?<button data-href="#Isn’t-Sharding-a-Natural-Solution-to-Scalability" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Масштабируемость можно решить несколькими способами. Самый простой подход, <strong>Scaling Up</strong>, подразумевает увеличение ресурсов одной машины за счет увеличения количества процессоров, памяти или хранилища для размещения растущих объемов данных. Несмотря на простоту, этот метод имеет очевидные ограничения. Например, в среде Kubernetes большие стручки неэффективны, а опора на один узел повышает риск сбоев, что может привести к значительным простоям.</p>
<p>Когда масштабирование вверх становится нецелесообразным, компании, естественно, переходят к <strong>масштабированию наружу</strong>, распределяя данные по нескольким серверам. На первый взгляд, <strong>шардинг</strong> является простым решением - разделение базы данных на более мелкие, независимые базы данных для увеличения емкости и создания нескольких первичных узлов с возможностью записи.</p>
<p>Однако, несмотря на концептуальную простоту, на практике шардинг быстро превращается в сложную задачу. Большинство приложений изначально рассчитаны на работу с единой, унифицированной базой данных. В тот момент, когда векторная база данных разделяется на несколько шардов, каждая часть приложения, взаимодействующая с данными, должна быть изменена или полностью переписана, что влечет за собой значительные затраты на разработку. Разработка эффективной стратегии разделения становится решающим фактором, как и реализация логики маршрутизации для обеспечения направления данных в нужный шард. Управление атомарными транзакциями в нескольких шардах часто требует реструктуризации приложений, чтобы избежать кросс-шардовых операций. Кроме того, сценарии сбоев должны обрабатываться изящно, чтобы предотвратить сбои в работе, когда некоторые шарды становятся недоступными.</p>
<h2 id="Why-Manual-Sharding-Becomes-a-Burden" class="common-anchor-header">Почему ручное шардирование становится непосильной ношей<button data-href="#Why-Manual-Sharding-Becomes-a-Burden" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>&quot;<em>Изначально мы рассчитывали, что внедрение ручного шардинга для нашей базы данных pgvector займет у двух инженеров около шести месяцев, -</em> вспоминает Алекс, <em>- но мы не понимали, что эти инженеры</em> <em>будут нужны</em> <strong><em>всегда</em></strong> <em>. Каждое изменение схемы, операция ребалансировки данных или решение о масштабировании требовали их специальных знаний. По сути, мы взяли на себя обязательство содержать постоянную &quot;команду шардинга&quot; только для того, чтобы поддерживать нашу базу данных в рабочем состоянии&quot;.</em></p>
<p>Реальные проблемы, возникающие при использовании векторных баз данных с шардингом, включают:</p>
<ol>
<li><p><strong>Дисбаланс распределения данных (горячие точки)</strong>: В многопользовательских системах распределение данных может составлять от сотен до миллиардов векторов на одного арендатора. Такой дисбаланс создает "горячие точки", когда одни шарды перегружаются, а другие простаивают.</p></li>
<li><p><strong>Головная боль, связанная с решардингом</strong>: Выбрать правильное количество шардов практически невозможно. Слишком малое количество приводит к частым и дорогостоящим операциям решардинга. Слишком большое количество создает ненужные накладные метаданные, увеличивая сложность и снижая производительность.</p></li>
<li><p><strong>Сложность изменения схемы</strong>: Многие векторные базы данных реализуют шардинг, управляя несколькими базовыми базами данных. Это делает синхронизацию изменений схемы между шардами громоздкой и подверженной ошибкам, что замедляет циклы разработки.</p></li>
<li><p><strong>Нерациональное использование ресурсов</strong>: В базах данных, связанных с хранением и вычислениями, необходимо тщательно распределять ресурсы между всеми узлами, предвидя будущий рост. Обычно, когда использование ресурсов достигает 60-70 %, необходимо начинать планировать перераспределение.</p></li>
</ol>
<p>Проще говоря, <strong>управление шардами вручную вредно для вашего бизнеса</strong>. Вместо того чтобы заставлять команду инженеров постоянно управлять шардами, подумайте о том, чтобы инвестировать в векторную базу данных, разработанную для автоматического масштабирования без операционного бремени.</p>
<h2 id="How-Milvus-Solves-the-Scalability-Problem" class="common-anchor-header">Как Milvus решает проблему масштабируемости<button data-href="#How-Milvus-Solves-the-Scalability-Problem" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Многие разработчики - от стартапов до предприятий - осознали значительные накладные расходы, связанные с ручным шардингом баз данных. Milvus использует принципиально иной подход, обеспечивая плавное масштабирование от миллионов до миллиардов векторов без лишних сложностей.</p>
<h3 id="Automated-Scaling-Without-the-Tech-Debt" class="common-anchor-header">Автоматизированное масштабирование без технического долга</h3><p>Milvus использует Kubernetes и дезагрегированную архитектуру хранения и вычислений для поддержки плавного расширения. Такая конструкция позволяет:</p>
<ul>
<li><p>Быстрое масштабирование в ответ на меняющиеся требования</p></li>
<li><p>Автоматическое распределение нагрузки между всеми доступными узлами</p></li>
<li><p>Независимое распределение ресурсов, позволяющее регулировать вычисления, память и хранилище по отдельности</p></li>
<li><p>Неизменно высокую производительность даже в периоды быстрого роста.</p></li>
</ul>
<h3 id="Distributed-Architecture-Designed-from-the-Ground-Up" class="common-anchor-header">Распределенная архитектура, разработанная с нуля</h3><p>Milvus достигает своих возможностей масштабирования благодаря двум ключевым инновациям:</p>
<p><strong>Архитектура, основанная на сегментах:</strong> В своей основе Milvus организует данные в &quot;сегменты&quot; - мельчайшие единицы управления данными:</p>
<ul>
<li><p>Растущие сегменты размещаются на StreamNodes, оптимизируя свежесть данных для запросов в реальном времени.</p></li>
<li><p>Уплотненные сегменты управляются узлами запросов (QueryNodes), использующими мощные индексы для ускорения поиска.</p></li>
<li><p>Эти сегменты равномерно распределяются по узлам для оптимизации параллельной обработки.</p></li>
</ul>
<p><strong>Двухуровневая маршрутизация</strong>: В отличие от традиционных баз данных, где каждый шард живет на одной машине, Milvus динамически распределяет данные в одном шарде по нескольким узлам:</p>
<ul>
<li><p>Каждый шард может хранить более 1 миллиарда точек данных.</p></li>
<li><p>Сегменты внутри каждого хранилища автоматически балансируются между машинами.</p></li>
<li><p>Расширение коллекций - это простое увеличение количества шардов.</p></li>
<li><p>В грядущей версии Milvus 3.0 будет реализовано динамическое разделение шардов, что исключит даже этот минимальный ручной шаг.</p></li>
</ul>
<h3 id="Query-Processing-at-Scale" class="common-anchor-header">Масштабная обработка запросов</h3><p>При выполнении запроса Milvus следует эффективному процессу:</p>
<ol>
<li><p>Прокси идентифицирует соответствующие шарды для запрашиваемой коллекции</p></li>
<li><p>Прокси собирает данные со StreamNodes и QueryNodes.</p></li>
<li><p>StreamNodes обрабатывают данные в реальном времени, а QueryNodes параллельно обрабатывают исторические данные.</p></li>
<li><p>Результаты агрегируются и возвращаются пользователю</p></li>
</ol>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Query_Processing_at_Scale_5792dc9e37.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="A-Different-Engineering-Experience" class="common-anchor-header">Иной инженерный опыт<button data-href="#A-Different-Engineering-Experience" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>"<em>Когда масштабируемость встроена в саму базу данных, все эти головные боли просто... исчезают", -</em> говорит Алекс, размышляя о переходе своей команды на Milvus. <em>"Мои инженеры вернулись к созданию функций, которые нравятся клиентам, вместо того чтобы нянчиться с осколками базы данных".</em></p>
<p>Если вы боретесь с инженерной нагрузкой, связанной с ручным шардингом, узкими местами в производительности при масштабировании или пугающей перспективой миграции баз данных, пришло время пересмотреть свой подход. Посетите нашу <a href="https://milvus.io/docs/overview.md#What-Makes-Milvus-so-Scalable">страницу документации</a>, чтобы узнать больше об архитектуре Milvus, или испытайте на себе легкость масштабирования с помощью полностью управляемой Milvus на сайте <a href="https://zilliz.com/cloud">zilliz.com/cloud</a>.</p>
<p>С правильной основой векторной базы данных ваши инновации не знают границ.</p>
