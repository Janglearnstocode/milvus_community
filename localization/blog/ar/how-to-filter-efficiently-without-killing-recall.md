---
id: how-to-filter-efficiently-without-killing-recall.md
title: 'البحث المتجه في العالم الحقيقي: كيفية التصفية بكفاءة دون قتل التذكر'
author: Chris Gao and Patrick Xu
date: 2025-05-12T00:00:00.000Z
desc: >-
  تستكشف هذه المدونة تقنيات التصفية الشائعة في البحث المتجه، إلى جانب التحسينات
  المبتكرة التي قمنا ببنائها في Milvus وZilliz Cloud.
cover: assets.zilliz.com/Filter_Efficiently_Without_Killing_Recall_1c355c229c.png
tag: Engineering
tags: 'Vector search, filtering vector search, vector search with filtering'
recommend: true
canonicalUrl: 'https://milvus.io/blog/how-to-filter-efficiently-without-killing-recall.md'
---
<p>يعتقد الكثير من الناس أن البحث المتجه يتعلق ببساطة بتنفيذ خوارزمية ANN (أقرب جار تقريبي) وينتهي الأمر. ولكن إذا كنت تقوم بتشغيل البحث المتجه في الإنتاج، فأنت تعرف الحقيقة: يصبح الأمر معقدًا بسرعة.</p>
<p>تخيل أنك تبني محرك بحث عن منتج. قد يسأل المستخدم: "<em>أرني حذاءً مشابهًا لهذه الصورة، ولكن باللون الأحمر فقط وبأقل من 100 دولار</em>". تتطلب خدمة هذا الاستعلام تطبيق فلتر بيانات وصفية على نتائج البحث عن التشابه الدلالي. يبدو بسيطًا مثل تطبيق فلتر بعد عوائد البحث المتجه؟ حسنًا، ليس تمامًا.</p>
<p>ماذا يحدث عندما يكون شرط التصفية انتقائيًا للغاية؟ قد لا ترجع نتائج كافية. وقد تؤدي زيادة معلمة <strong>TopK</strong> للبحث المتجه ببساطة إلى تدهور الأداء بسرعة واستهلاك المزيد من الموارد بشكل كبير للتعامل مع نفس حجم البحث.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Show_me_shoes_similar_to_this_photo_but_only_in_red_and_under_100_0862a41a60.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>تحت الغطاء، تعتبر تصفية البيانات الوصفية الفعالة للبيانات الوصفية صعبة للغاية. تحتاج قاعدة بياناتك المتجهة إلى مسح فهرس الرسم البياني وتطبيق مرشحات البيانات الوصفية والاستجابة في حدود ميزانية كمون ضيقة، لنقل 20 ميلي ثانية. تتطلب خدمة الآلاف من هذه الاستعلامات في الثانية الواحدة دون أن تفلس هندسة مدروسة وتحسين دقيق.</p>
<p>تستكشف هذه المدونة تقنيات التصفية الشائعة في البحث المتجه، إلى جانب التحسينات المبتكرة التي قمنا ببنائها في قاعدة بيانات <a href="https://milvus.io/docs/overview.md">Milvus</a> vector وخدمتها السحابية المدارة بالكامل<a href="https://zilliz.com/cloud">(Zilliz Cloud</a>). كما سنشارك أيضًا اختبارًا معياريًا يوضح مدى الأداء الذي يمكن أن تحققه خدمة Milvus المدارة بالكامل بميزانية سحابية تبلغ 1000 دولار أمريكي مقارنةً بقواعد البيانات المتجهة الأخرى.</p>
<h2 id="Graph-Index-Optimization" class="common-anchor-header">تحسين فهرس الرسم البياني<button data-href="#Graph-Index-Optimization" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تحتاج قواعد البيانات المتجهة إلى طرق فهرسة فعالة للتعامل مع مجموعات البيانات الكبيرة. فبدون الفهارس، يجب أن تقارن قاعدة البيانات استعلامك مع كل متجه في مجموعة البيانات (المسح الضوئي الغاشم)، والذي يصبح بطيئًا للغاية مع نمو بياناتك.</p>
<p>يدعم<strong>ميلفوس</strong> أنواعًا مختلفة من الفهارس لحل هذا التحدي في الأداء. أكثرها شيوعًا هي أنواع الفهارس القائمة على الرسم البياني: HNSW (يعمل بالكامل في الذاكرة) و DiskANN (يستخدم الذاكرة و SSD بكفاءة). تنظم هذه الفهارس المتجهات في بنية شبكة حيث يتم ربط أحياء المتجهات على الخريطة، مما يسمح لعمليات البحث بالانتقال بسرعة إلى النتائج ذات الصلة مع فحص جزء صغير فقط من جميع المتجهات. تتقدم خدمة <strong>Zilliz Cloud،</strong> وهي خدمة Milvus المدارة بالكامل، خطوة أخرى إلى الأمام من خلال تقديم Cardinal، وهو محرك بحث متجه متقدم مملوك، مما يعزز هذه الفهارس لتحقيق أداء أفضل.</p>
<p>ومع ذلك، عندما نضيف متطلبات التصفية (مثل "إظهار المنتجات الأقل من 100 دولار فقط"، تظهر مشكلة جديدة. يتمثل النهج القياسي في إنشاء <em>مجموعة بتات</em> - قائمة تحدد المتجهات التي تلبي معايير التصفية. أثناء البحث، لا يأخذ النظام في الاعتبار سوى المتجهات التي تم تمييزها على أنها صالحة في مجموعة البتات هذه. يبدو هذا النهج منطقيًا، لكنه يخلق مشكلة خطيرة: <strong>الاتصال المقطوع</strong>. عندما يتم تصفية العديد من المتجهات، تتعطل المسارات التي تم إنشاؤها بعناية في فهرس الرسم البياني لدينا.</p>
<p>إليك مثال بسيط على المشكلة: في الرسم البياني أدناه، النقطة (أ) تتصل بالنقاط (ب) و(ج) و(د)، لكن النقاط (ب) و(ج) و(د) لا تتصل ببعضها البعض مباشرةً. إذا قام مرشحنا بإزالة النقطة أ (ربما يكون ذلك مكلفًا للغاية)، فحتى لو كانت النقاط ب، ج، د ذات صلة بالبحث، فإن المسار بينها مقطوع. يؤدي هذا إلى إنشاء "جزر" من المتجهات المنفصلة التي لا يمكن الوصول إليها أثناء البحث، مما يضر بجودة النتائج (الاستدعاء).</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/simple_example_of_the_problem_0f09b36639.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>هناك طريقتان شائعتان للتصفية أثناء اجتياز الرسم البياني: استبعاد جميع النقاط التي تمت تصفيتها مقدمًا، أو تضمين كل شيء وتطبيق التصفية بعد ذلك. كما هو موضح في الرسم البياني أدناه، لا يعتبر أي من الطريقتين مثاليًا. يمكن أن يؤدي تخطي النقاط التي تمت تصفيتها بالكامل إلى انهيار الاستدعاء عندما تقترب نسبة التصفية من 1 (الخط الأزرق)، بينما تؤدي زيارة كل نقطة بغض النظر عن بياناتها الوصفية إلى تضخم مساحة البحث وإبطاء الأداء بشكل كبير (الخط الأحمر).</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Filtering_ratio_911e32783b.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>اقترح الباحثون عدة طرق لتحقيق التوازن بين التذكر والأداء:</p>
<ol>
<li><strong>استراتيجية ألفا:</strong> يقدم هذا نهجًا احتماليًا: على الرغم من أن المتجه لا يتطابق مع المرشح، إلا أننا قد نستمر في زيارته أثناء البحث مع بعض الاحتمالات. يعتمد هذا الاحتمال (ألفا) على نسبة التصفية - مدى صرامة المرشح. يساعد هذا في الحفاظ على الروابط الأساسية في الرسم البياني دون زيارة الكثير من المتجهات غير ذات الصلة.</li>
</ol>
<ol start="2">
<li><strong>طريقة ACORN [1]:</strong> في HNSW القياسي، يتم استخدام تشذيب الحواف أثناء إنشاء الفهرس لإنشاء رسم بياني متناثر وتسريع البحث. تتخطى طريقة ACORN خطوة التقليم هذه عمدًا للاحتفاظ بالمزيد من الحواف وتقوية الاتصال - وهو أمر بالغ الأهمية عندما تستبعد المرشحات العديد من العقد. في بعض الحالات، تقوم ACORN أيضًا بتوسيع قائمة جيران كل عقدة من خلال جمع جيران إضافيين تقريبيين أقرب، مما يعزز الرسم البياني بشكل أكبر. وعلاوة على ذلك، تبحث خوارزمية اجتيازها عن خطوتين للأمام (أي تفحص جيران الجيران)، مما يحسن فرص العثور على مسارات صالحة حتى في ظل نسب التصفية العالية.</li>
</ol>
<ol start="3">
<li><strong>الجيران المختارون ديناميكيًا:</strong> طريقة تتحسن على استراتيجية ألفا. فبدلاً من الاعتماد على التخطي الاحتمالي، يقوم هذا الأسلوب باختيار العقد التالية بشكل تكيّفي أثناء البحث. يوفر تحكمًا أكثر من استراتيجية ألفا.</li>
</ol>
<p>في ميلفوس، قمنا بتطبيق استراتيجية ألفا إلى جانب تقنيات تحسين أخرى. على سبيل المثال، تقوم بتبديل الاستراتيجيات ديناميكيًا عند اكتشاف مرشحات انتقائية للغاية: عندما لا تتطابق 99% تقريبًا من البيانات مع تعبير التصفية على سبيل المثال، فإن استراتيجية "تضمين الكل" قد تتسبب في إطالة مسارات اجتياز الرسم البياني بشكل كبير، مما يؤدي إلى تدهور الأداء و"جزر" معزولة من البيانات. في مثل هذه الحالات، يتراجع Milvus تلقائيًا إلى الفحص بالقوة الغاشمة، متجاوزًا فهرس الرسم البياني بالكامل لتحقيق كفاءة أفضل. في Cardinal، وهو محرك البحث المتجه الذي يعمل على تشغيل Milvus المُدار بالكامل (Zilliz Cloud)، قمنا بتطوير هذا الأمر من خلال تنفيذ مزيج ديناميكي من أساليب اجتياز "تضمين الكل" و"استبعاد الكل" التي تتكيف بذكاء بناءً على إحصائيات البيانات لتحسين أداء الاستعلام.</p>
<p>تُظهر تجاربنا على مجموعة بيانات Cohere 1M (البُعد = 768) باستخدام مثيل AWS r7gd.4xlarge فعالية هذا النهج. في الرسم البياني أدناه، يمثل الخط الأزرق استراتيجية الدمج الديناميكية الخاصة بنا، بينما يوضح الخط الأحمر النهج الأساسي الذي يجتاز جميع النقاط المفلترة في الرسم البياني.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Graph_2_067a13500b.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Metadata-Aware-Indexing" class="common-anchor-header">الفهرسة الواعية بالبيانات الوصفية<button data-href="#Metadata-Aware-Indexing" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>يأتي التحدي الآخر من كيفية ارتباط البيانات الوصفية والتضمينات المتجهة ببعضها البعض. في معظم التطبيقات، يكون لخصائص البيانات الوصفية للعنصر (على سبيل المثال، سعر المنتج) صلة ضئيلة بما يمثله المتجه بالفعل (المعنى الدلالي أو السمات المرئية). على سبيل المثال، يشترك <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><annotation encoding="application/x-tex">فستان</annotation><mrow><mi>90dressanda90</mi></mrow></semantics></math></span></span>وحزام <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">90dressanda90</span><span class="strut" style="height:0.6944em;"></span><span class="mord"></span></span></span></span>في نفس السعر ولكنهما يظهران خصائص بصرية مختلفة تمامًا. هذا الانفصال يجعل الجمع بين التصفية والبحث المتجه غير فعال بطبيعته.</p>
<p>لحل هذه المشكلة، قمنا بتطوير <strong>فهارس متجهات مدركة للبيانات الوصفية</strong>. فبدلاً من وجود رسم بياني واحد فقط لجميع المتجهات، تقوم ببناء "رسوم بيانية فرعية" متخصصة لقيم البيانات الوصفية المختلفة. على سبيل المثال، إذا كانت بياناتك تحتوي على حقول ل "اللون" و "الشكل"، فإنه ينشئ هياكل رسم بياني منفصلة لهذه الحقول.</p>
<p>عندما تبحث باستخدام عامل تصفية مثل "اللون = أزرق"، فإنه يستخدم الرسم البياني الفرعي الخاص بالألوان بدلًا من الرسم البياني الرئيسي. هذا أسرع بكثير لأن الرسم البياني الفرعي منظم بالفعل حول البيانات الوصفية التي تقوم بالتصفية حسبها.</p>
<p>في الشكل أدناه، يُطلق على فهرس الرسم البياني الرئيسي <strong>الرسم البياني الأساسي،</strong> بينما تُسمى الرسوم البيانية المتخصصة المبنية لحقول بيانات وصفية محددة <strong>بالرسوم البيانية العمودية</strong>. لإدارة استخدام الذاكرة بشكل فعال، فإنه يحد من عدد الاتصالات التي يمكن أن تحتويها كل نقطة (درجة خارجية). عندما لا يتضمن البحث أي عوامل تصفية للبيانات الوصفية، فإنه يتم تعيينه افتراضيًا إلى الرسم البياني الأساسي. عند تطبيق عوامل التصفية، يتحول إلى الرسم البياني العمودي المناسب، مما يوفر ميزة سرعة كبيرة.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Metadata_Aware_Indexing_7c3e0707d9.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Iterative-Filtering" class="common-anchor-header">التصفية التكرارية<button data-href="#Iterative-Filtering" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>في بعض الأحيان تصبح التصفية نفسها عنق الزجاجة وليس البحث المتجه. يحدث هذا بشكل خاص مع المرشحات المعقدة مثل شروط JSON أو مقارنات السلاسل التفصيلية. يمكن أن يكون النهج التقليدي (التصفية أولاً، ثم البحث) بطيئًا للغاية لأن النظام يجب أن يقيّم هذه المرشحات المكلفة على ملايين السجلات المحتملة قبل بدء البحث المتجه.</p>
<p>قد تفكر: "لماذا لا تقوم بالبحث المتجه أولاً، ثم تصفية النتائج العليا؟ يعمل هذا النهج في بعض الأحيان، ولكن به عيب كبير: إذا كان عامل التصفية صارمًا ويقوم بتصفية معظم النتائج، فقد ينتهي بك الأمر بنتائج قليلة جدًا (أو صفر) بعد التصفية.</p>
<p>لحل هذه المعضلة، أنشأنا <strong>التصفية التكرارية</strong> في ميلفوس وزيليز كلاود، المستوحاة من<a href="https://www.usenix.org/system/files/osdi23-zhang-qianxi_1.pdf"> VBase</a>. بدلاً من نهج الكل أو لا شيء، تعمل التصفية التكرارية على دفعات:</p>
<ol>
<li><p>الحصول على مجموعة من أقرب المتجهات المتطابقة</p></li>
<li><p>تطبيق المرشحات على هذه الدفعة</p></li>
<li><p>إذا لم يكن لدينا ما يكفي من النتائج المصفاة، احصل على دفعة أخرى</p></li>
<li><p>كرر حتى نحصل على العدد المطلوب من النتائج</p></li>
</ol>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Iterative_Filtering_b65a057559.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>يقلل هذا النهج بشكل كبير من عدد عمليات التصفية المكلفة التي نحتاج إلى إجرائها مع ضمان حصولنا على نتائج كافية عالية الجودة. لمزيد من المعلومات حول تمكين التصفية التكرارية، يُرجى الرجوع إلى <a href="https://docs.zilliz.com/docs/filtered-search#iterative-filtering">صفحة مستند التصفية التكرارية</a> هذه.</p>
<h2 id="External-Filtering" class="common-anchor-header">التصفية الخارجية<button data-href="#External-Filtering" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>تقوم العديد من التطبيقات الواقعية بتقسيم بياناتها عبر أنظمة مختلفة - المتجهات في قاعدة بيانات المتجهات والبيانات الوصفية في قواعد البيانات التقليدية. على سبيل المثال، تقوم العديد من المؤسسات بتخزين أوصاف المنتجات ومراجعات المستخدمين كمتجهات في Milvus للبحث الدلالي، مع الاحتفاظ بحالة المخزون والتسعير والبيانات المنظمة الأخرى في قواعد البيانات التقليدية مثل PostgreSQL أو MongoDB.</p>
<p>هذا الفصل منطقي من الناحية المعمارية، ولكنه يخلق تحديًا لعمليات البحث المفلترة. يصبح سير العمل النموذجي</p>
<ul>
<li><p>الاستعلام عن قاعدة البيانات العلائقية الخاصة بك بحثًا عن السجلات المطابقة لمعايير التصفية (على سبيل المثال، "العناصر الموجودة في المخزون التي تقل قيمتها عن 50 دولارًا")</p></li>
<li><p>الحصول على المعرفات المطابقة وإرسالها إلى ميلفوس لتصفية البحث المتجه</p></li>
<li><p>إجراء البحث الدلالي فقط على المتجهات التي تطابق هذه المعرفات</p></li>
</ul>
<p>يبدو هذا الأمر بسيطاً - ولكن عندما يزيد عدد الصفوف عن الملايين، يصبح عنق الزجاجة. يستهلك نقل قوائم كبيرة من المعرفات عرض النطاق الترددي للشبكة، ويضيف تنفيذ تعبيرات التصفية الضخمة في ميلفوس نفقات زائدة.</p>
<p>ولمعالجة ذلك، قدمنا <strong>التصفية الخارجية</strong> في Milvus، وهو حل خفيف الوزن على مستوى SDK يستخدم واجهة برمجة تطبيقات مكرر البحث ويعكس سير العمل التقليدي.</p>
<ul>
<li><p>يُجري البحث المتجه أولاً، ويسترجع مجموعات من المرشحين الأكثر صلة من الناحية الدلالية</p></li>
<li><p>يطبق وظيفة التصفية المخصصة الخاصة بك على كل دفعة من جانب العميل</p></li>
<li><p>يجلب المزيد من الدفعات تلقائيًا حتى تحصل على نتائج مصفاة كافية</p></li>
</ul>
<p>يقلل هذا النهج التكراري المجمّع على دفعات من حركة مرور الشبكة ونفقات المعالجة بشكل كبير، نظرًا لأنك تعمل فقط مع أكثر المرشحين الواعدين من البحث المتجه.</p>
<p>إليك مثال على كيفية استخدام التصفية الخارجية في pymilvus:</p>
<pre><code translate="no">vector_to_search = rng.random((<span class="hljs-number">1</span>, DIM), np.float32)
expr = <span class="hljs-string">f&quot;10 &lt;= <span class="hljs-subst">{AGE}</span> &lt;= 25&quot;</span>
valid_ids = [<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">123</span>, <span class="hljs-number">1234</span>]

<span class="hljs-keyword">def</span> <span class="hljs-title function_">external_filter_func</span>(<span class="hljs-params">hits: Hits</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> hit: hit.<span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> valid_ids, hits))

search_iterator = milvus_client.search_iterator(
    collection_name=collection_name,
    data=vector_to_search,
    batch_size=<span class="hljs-number">100</span>,
    anns_field=PICTURE,
    <span class="hljs-built_in">filter</span>=expr,
    external_filter_func=external_filter_func,
    output_fields=[USER_ID, AGE]
)

<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    res = search_iterator.<span class="hljs-built_in">next</span>()
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span>:
        search_iterator.close()
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):
        <span class="hljs-built_in">print</span>(res[i])
<button class="copy-code-btn"></button></code></pre>
<p>على عكس التصفية التكرارية، التي تعمل على مكررين على مستوى المقاطع، تعمل التصفية الخارجية على مستوى الاستعلام العام. يقلل هذا التصميم من تقييم البيانات الوصفية ويتجنب تنفيذ عوامل التصفية الكبيرة داخل ميلفوس، مما يؤدي إلى أداء أقل حجماً وأسرع من طرف إلى طرف.</p>
<h2 id="AutoIndex" class="common-anchor-header">الفهرس التلقائي<button data-href="#AutoIndex" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>ينطوي البحث في المتجهات دائمًا على مفاضلة بين الدقة والسرعة - فكلما زاد عدد المتجهات التي تتحقق منها، كانت نتائجك أفضل ولكن الاستعلام أبطأ. عند إضافة الفلاتر، يصبح هذا التوازن أكثر صعوبة في تحقيق التوازن الصحيح.</p>
<p>في Zilliz Cloud، أنشأنا في Zilliz Cloud أداة <strong>AutoIndex</strong> - وهي أداة تحسين قائمة على التعلم الآلي تقوم تلقائيًا بضبط هذا التوازن من أجلك. بدلاً من تكوين المعلمات المعقدة يدويًا، يستخدم AutoIndex التعلم الآلي لتحديد الإعدادات المثلى لبياناتك وأنماط الاستعلام الخاصة بك.</p>
<p>ولفهم كيفية عمل ذلك، من المفيد معرفة القليل عن بنية ميلفوس نظرًا لأن Zilliz مبني على رأس ميلفوس: يتم توزيع الاستعلامات عبر مثيلات QueryNode متعددة. تتعامل كل عقدة مع جزء من بياناتك (مقطع)، وتقوم بإجراء البحث الخاص بها، ثم يتم دمج النتائج معًا.</p>
<p>يقوم الفهرس التلقائي بتحليل الإحصائيات من هذه المقاطع وإجراء تعديلات ذكية. بالنسبة لنسبة التصفية المنخفضة، يتم توسيع نطاق استعلام الفهرس لزيادة الاستدعاء. بالنسبة لنسبة التصفية المرتفعة، يتم تضييق نطاق الاستعلام لتجنب إهدار الجهد على المرشحين غير المحتملين. تسترشد هذه القرارات بالنماذج الإحصائية التي تتنبأ باستراتيجية البحث الأكثر فعالية لكل سيناريو تصفية محدد.</p>
<p>يتجاوز الفهرس التلقائي معلمات الفهرسة. فهو يساعد أيضًا في تحديد أفضل استراتيجية تقييم للتصفية. من خلال تحليل تعبيرات التصفية وأخذ عينات من بيانات المقطع، يمكنه تقدير تكلفة التقييم. إذا اكتشف تكاليف تقييم عالية، فإنه يتحول تلقائيًا إلى تقنيات أكثر كفاءة مثل التصفية التكرارية. يضمن هذا التعديل الديناميكي أنك تستخدم دائمًا أفضل استراتيجية مناسبة لكل استعلام.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Autoindex_3f37988d5c.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Performance-on-a-1000-Budget" class="common-anchor-header">الأداء بميزانية 1000 دولار<button data-href="#Performance-on-a-1000-Budget" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>على الرغم من أهمية التحسينات النظرية، فإن الأداء في العالم الحقيقي هو ما يهم معظم المطورين. أردنا اختبار كيفية ترجمة هذه التحسينات إلى أداء التطبيق الفعلي في ظل قيود الميزانية الواقعية.</p>
<p>لقد قمنا بقياس العديد من حلول قواعد البيانات المتجهة بميزانية شهرية عملية بقيمة 1000 دولار - وهو مبلغ معقول قد تخصصه العديد من الشركات للبنية التحتية للبحث المتجه. بالنسبة لكل حل، قمنا باختيار أعلى تكوين ممكن للمثيلات أداءً ضمن قيود الميزانية هذه.</p>
<p>استخدمنا في اختبارنا:</p>
<ul>
<li><p>مجموعة بيانات Cohere 1M التي تحتوي على مليون متجه ذي 768 متجهًا من 768 بُعدًا</p></li>
<li><p>مزيج من أعباء عمل البحث المصفاة وغير المصفاة في العالم الحقيقي</p></li>
<li><p>الأداة المعيارية vdb-bench مفتوحة المصدر لإجراء مقارنات متسقة</p></li>
</ul>
<p>تم تهيئة جميع الحلول المتنافسة (مجهولة الهوية باسم "VDB A" و"VDB B" و"VDB C") على النحو الأمثل في حدود الميزانية. أظهرت النتائج أن Milvus المدار بالكامل (Zilliz Cloud) حقق باستمرار أعلى إنتاجية عبر كل من الاستعلامات المصفاة وغير المصفاة. وبنفس الميزانية التي تبلغ 1000 دولار أمريكي، حققت تقنيات التحسين التي قمنا بها أعلى أداء في حدود الميزانية.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Performance_on_a_1_000_Budget_5ebefaec48.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<h2 id="Conclusion" class="common-anchor-header">الخلاصة<button data-href="#Conclusion" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>قد يبدو البحث المتجه مع التصفية بسيطًا ظاهريًا - ما عليك سوى إضافة بند تصفية إلى استعلامك وتنتهي. ومع ذلك، وكما أوضحنا في هذه المدونة، فإن تحقيق الأداء العالي والنتائج الدقيقة على نطاق واسع يتطلب حلولاً هندسية متطورة. تعالج ميلفوس وزيليز كلاود هذه التحديات من خلال عدة أساليب مبتكرة:</p>
<ul>
<li><p><strong>تحسين فهرس الرسم البياني</strong>: يحافظ على المسارات بين العناصر المتشابهة حتى عند إزالة المرشحات للعقد المتصلة، مما يمنع مشكلة "الجزر" التي تقلل من جودة النتائج.</p></li>
<li><p><strong>الفهرسة الواعية بالبيانات الوصفية</strong>: ينشئ مسارات متخصصة لظروف التصفية الشائعة، مما يجعل عمليات البحث التي تمت تصفيتها أسرع بكثير دون التضحية بالدقة.</p></li>
<li><p><strong>التصفية التكرارية</strong>: يعالج النتائج على دفعات، ويطبق الفلاتر المعقدة فقط على أكثر المرشحين الواعدين بدلاً من مجموعة البيانات بأكملها.</p></li>
<li><p><strong>الفهرس التلقائي</strong>: يستخدم التعلُّم الآلي لضبط معلمات البحث تلقائيًا بناءً على بياناتك واستفساراتك، مما يحقق التوازن بين السرعة والدقة دون الحاجة إلى تكوين يدوي.</p></li>
<li><p><strong>التصفية الخارجية</strong>: يربط بين البحث المتجه وقواعد البيانات الخارجية بكفاءة، مما يقضي على اختناقات الشبكة مع الحفاظ على جودة النتائج.</p></li>
</ul>
<p>يستمر ميلفوس وزيليز كلاود في التطور مع قدرات جديدة تزيد من تحسين أداء البحث المصفى. تسمح ميزات مثل<a href="https://docs.zilliz.com/docs/use-partition-key"> مفتاح التقسيم</a> بتنظيم البيانات بشكل أكثر كفاءة استنادًا إلى أنماط التصفية، كما أن تقنيات التوجيه الفرعي المتقدمة تدفع حدود الأداء إلى أبعد من ذلك.</p>
<p>يستمر حجم وتعقيد البيانات غير المهيكلة في النمو بشكل كبير، مما يخلق تحديات جديدة لأنظمة البحث في كل مكان. يعمل فريقنا باستمرار على دفع حدود ما هو ممكن مع قواعد البيانات المتجهة لتقديم بحث أسرع وأكثر قابلية للتطوير مدعوم بالذكاء الاصطناعي.</p>
<p>إذا كانت تطبيقاتك تعاني من اختناقات في الأداء مع البحث المتجه المصفى، فإننا ندعوك للانضمام إلى مجتمع المطورين النشط لدينا على <a href="https://milvus.io/community">milvus.io/community</a> - حيث يمكنك مشاركة التحديات والوصول إلى إرشادات الخبراء واكتشاف أفضل الممارسات الناشئة.</p>
<h2 id="References" class="common-anchor-header">المراجع<button data-href="#References" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><ol>
<li><p><a href="https://arxiv.org/pdf/2403.04871">https://arxiv.org/pdf/2403.04871</a></p></li>
<li><p><a href="https://www.usenix.org/system/files/osdi23-zhang-qianxi_1.pdf">https://www.usenix.org/system/files/osdi23-zhang-qianxi_1.pdf</a></p></li>
</ol>
<hr>
