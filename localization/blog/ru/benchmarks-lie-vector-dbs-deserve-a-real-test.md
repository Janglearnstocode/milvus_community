---
id: benchmarks-lie-vector-dbs-deserve-a-real-test.md
title: Бенчмарки лгут - векторные БД заслуживают реального тестирования
author: Min Tian
date: 2025-05-14T00:00:00.000Z
desc: >-
  Выявите недостаток производительности векторных баз данных с помощью VDBBench.
  Наш инструмент проводит тестирование в реальных производственных сценариях,
  обеспечивая бесперебойную работу ваших приложений искусственного интеллекта
  без непредвиденных простоев.
cover: >-
  assets.zilliz.com/Benchmarks_Lie_Vector_D_Bs_Deserve_a_Real_Test_9280c66efc.png
tag: Engineering
recommend: true
publishToMedium: true
tags: 'Milvus, vector database, vector search, AI Agents, LLM'
meta_keywords: >-
  Vector database, vectordbbench, vector database benchmark, vector search
  performance
meta_title: |
  Benchmarks Lie — Vector DBs Deserve a Real Test
origin: 'https://milvus.io/blog/benchmarks-lie-vector-dbs-deserve-a-real-test.md'
---
<h2 id="The-Vector-Database-You-Chose-Based-on-Benchmarks-Might-Fail-in-Production" class="common-anchor-header">Векторная база данных, которую вы выбрали на основе бенчмарков, может оказаться неудачной в производстве<button data-href="#The-Vector-Database-You-Chose-Based-on-Benchmarks-Might-Fail-in-Production" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>При выборе <a href="https://milvus.io/blog/what-is-a-vector-database.md">векторной базы данных</a> для приложения ИИ обычные контрольные показатели похожи на тест-драйв спортивного автомобиля на пустой трассе, который может заглохнуть в пробке в час пик. Неудобная правда? Большинство бенчмарков оценивают производительность только в искусственных условиях, которые никогда не существуют в производственных средах.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Benchmarks_Lie_Vector_D_Bs_Deserve_a_Real_Test_9280c66efc.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p>Большинство бенчмарков тестируют векторные базы данных <strong>после того, как</strong> все данные уже поступили и индекс полностью сформирован. Но в производстве поток данных никогда не прекращается. Вы не можете приостановить работу системы на несколько часов только для того, чтобы перестроить индекс.</p>
<p>Мы убедились в этом на собственном опыте. Например, Elasticsearch может похвастаться миллисекундной скоростью выполнения запросов, но за кулисами мы наблюдали, как у него уходит <strong>более 20 часов</strong> только на оптимизацию индекса. Такое время простоя не может позволить себе ни одна производственная система, особенно в рабочих нагрузках искусственного интеллекта, требующих постоянных обновлений и мгновенных ответов.</p>
<p>Проведя бесчисленное количество испытаний концепций (Proof of Concept, PoC) с корпоративными клиентами, компания Milvus выявила тревожную закономерность: <strong>векторные базы данных, которые отлично работают в контролируемых лабораторных условиях, часто испытывают трудности при реальных производственных нагрузках.</strong> Этот критический недостаток не просто расстраивает инженеров инфраструктуры - он может свести на нет все инициативы в области искусственного интеллекта, построенные на этих обманчивых обещаниях производительности.</p>
<p>Именно поэтому мы создали <a href="https://github.com/zilliztech/VectorDBBench">VDBBench</a>- бенчмарк с открытым исходным кодом, разработанный с нуля для моделирования реальных производственных условий. В отличие от синтетических тестов с выборочными сценариями, VDBBench подвергает базы данных непрерывному поступлению данных, строгим условиям фильтрации и разнообразным сценариям, подобно реальным производственным рабочим нагрузкам. Наша миссия проста: предоставить инженерам инструмент, который показывает, как векторные базы данных работают в реальных условиях, чтобы вы могли принимать инфраструктурные решения на основе достоверных цифр.</p>
<h2 id="The-Gap-between-Benchmarks-and-Reality" class="common-anchor-header">Разрыв между эталонными показателями и реальностью<button data-href="#The-Gap-between-Benchmarks-and-Reality" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Традиционные подходы к бенчмаркингу страдают тремя критическими недостатками, которые делают их результаты практически бессмысленными для принятия производственных решений:</p>
<h3 id="1-Outdated-Data" class="common-anchor-header">1. Устаревшие данные</h3><p>Многие бенчмарки по-прежнему опираются на устаревшие наборы данных, такие как SIFT или<a href="https://zilliz.com/glossary/glove"> GloVe</a>, которые мало похожи на современные сложные, высокоразмерные векторные вкрапления, генерируемые моделями искусственного интеллекта. Подумайте вот о чем: SIFT содержит 128-мерные векторы, в то время как популярные вкрапления, созданные моделями вкраплений OpenAI, имеют от 768 до 3072 измерений.</p>
<h3 id="2-Vanity-Metrics" class="common-anchor-header">2. Тщеславные метрики</h3><p>Многие бенчмарки ориентируются исключительно на среднюю задержку или пиковый QPS, что создает искаженную картину. Эти идеализированные показатели не позволяют учесть отклонения и несоответствия, с которыми сталкиваются реальные пользователи в производственных средах. Например, какой толк от впечатляющего числа QPS, если для этого требуются неограниченные вычислительные ресурсы, которые разорят вашу организацию?</p>
<h3 id="3-Oversimplified-Scenarios" class="common-anchor-header">3. Чрезмерно упрощенные сценарии</h3><p>Большинство бенчмарков тестируют только базовые, статичные рабочие нагрузки - по сути, "Hello World" векторного поиска. Например, они выдают поисковые запросы только после того, как весь набор данных получен и проиндексирован, игнорируя динамическую реальность, в которой пользователи ищут, пока поступают новые данные. Такой упрощенный дизайн не учитывает сложные паттерны, определяющие реальные производственные системы, такие как одновременные запросы, фильтрованный поиск и непрерывное поступление данных.</p>
<p>Осознав эти недостатки, мы поняли, что индустрии необходим <strong>радикальный сдвиг в философии бенчмаркинга,</strong>основанный на том, как системы ИИ ведут себя в реальных условиях. Именно поэтому мы создали <a href="https://github.com/zilliztech/VectorDBBench">VDBBench</a>.</p>
<h2 id="From-Lab-to-Production-How-VDBBench-Bridges-the-Gap" class="common-anchor-header">От лаборатории к производству: Как VDBBench преодолевает разрыв<button data-href="#From-Lab-to-Production-How-VDBBench-Bridges-the-Gap" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>VDBBench не просто повторяет устаревшую философию бенчмаркинга - он перестраивает концепцию с первых принципов, руководствуясь одним главным убеждением: <strong>бенчмарк ценен только в том случае, если он предсказывает реальное поведение на производстве</strong>.</p>
<p>Мы разработали VDBBench для точного воспроизведения реальных условий по трем важнейшим параметрам: подлинность данных, модели рабочей нагрузки и измерение производительности.</p>
<h3 id="Modernizing-the-Dataset" class="common-anchor-header">Модернизация набора данных</h3><p>Мы полностью переработали наборы данных, используемые для бенчмаркинга vectorDB. Вместо устаревших тестовых наборов, таких как SIFT и GloVe, в VDBBench используются векторы, созданные на основе современных моделей встраивания, которые используются в современных приложениях ИИ.</p>
<p>Для обеспечения актуальности, особенно для таких сценариев использования, как Retrieval-Augmented Generation (RAG), мы выбрали корпорации, которые отражают реальные сценарии работы предприятий и конкретных областей. Они варьируются от баз знаний общего назначения до вертикальных приложений, таких как ответы на биомедицинские вопросы и крупномасштабный веб-поиск.</p>
<table>
<thead>
<tr><th></th><th></th><th></th><th></th></tr>
</thead>
<tbody>
<tr><td><strong>Корпус</strong></td><td><strong>Модель встраивания</strong></td><td><strong>Размеры</strong></td><td><strong>Размер</strong></td></tr>
<tr><td>Википедия</td><td>Cohere V2</td><td>768</td><td>1M / 10M</td></tr>
<tr><td>BioASQ</td><td>Cohere V3</td><td>1024</td><td>1M / 10M</td></tr>
<tr><td>C4</td><td>OpenAI</td><td>1536</td><td>500K / 5M</td></tr>
<tr><td>MSMarco V2</td><td>udever-bloom-1b1</td><td>1536</td><td>1М / 10М / 138М</td></tr>
</tbody>
</table>
<p>Таблица: Наборы данных, используемые в VDBBench</p>
<p>VDBBench также поддерживает пользовательские наборы данных, позволяя вам проводить бенчмаркинг с использованием собственных данных, сгенерированных на основе конкретных моделей встраивания для конкретных рабочих нагрузок. В конце концов, ни один набор данных не расскажет лучше, чем ваши собственные производственные данные.</p>
<h3 id="Production-Focused-Metric-Design" class="common-anchor-header">Разработка метрик, ориентированных на производство</h3><p><strong>VDBBench отдает предпочтение метрикам, которые отражают реальную производительность, а не просто лабораторные результаты.</strong> Мы переработали бенчмарки с учетом того, что действительно важно в производственных средах: надежность под нагрузкой, задержка на хвосте, устойчивая пропускная способность и точность.</p>
<ul>
<li><p><strong>Задержки P95/P99 для измерения реального опыта пользователей</strong>: Среднее/среднее значение задержки маскирует отклонения, которые расстраивают реальных пользователей. Именно поэтому VDBBench фокусируется на хвостовой задержке, такой как P95/P99, показывая, какой производительности на самом деле достигнут 95% или 99% ваших запросов.</p></li>
<li><p><strong>Устойчивая пропускная способность под нагрузкой:</strong> Система, которая хорошо работает в течение 5 секунд, не подходит для производства. VDBBench постепенно увеличивает параллелизм, чтобы найти максимальное количество устойчивых запросов в секунду для вашей базы данных (<code translate="no">max_qps</code>)- не пиковое число в коротких идеальных условиях. Это показывает, насколько хорошо ваша система выдерживает нагрузку с течением времени.</p></li>
<li><p><strong>Отзыв сбалансирован с производительностью:</strong> Скорость без точности бессмысленна. Каждое число производительности в VDBBench сопряжено с показателем запоминаемости, так что вы точно знаете, насколько релевантность вы уступаете пропускной способности. Это позволяет честно сравнивать системы с совершенно разными внутренними характеристиками.</p></li>
</ul>
<h3 id="Test-Methodology-That-Reflects-Reality" class="common-anchor-header">Методология тестирования, отражающая реальность</h3><p>Ключевым нововведением в VDBBench является <strong>разделение последовательного и параллельного тестирования</strong>, что помогает понять, как ведут себя системы при различных типах нагрузки. Например, показатели задержки делятся следующим образом:</p>
<ul>
<li><p><code translate="no">serial_latency_p99</code> измеряет производительность системы при минимальной нагрузке, когда за раз обрабатывается только один запрос. Это <em>наилучший сценарий</em> для задержки.</p></li>
<li><p><code translate="no">conc_latency_p99</code> измеряет поведение системы в <em>реалистичных, высококонкурентных условиях</em>, когда несколько запросов поступают одновременно.</p></li>
</ul>
<h3 id="Two-Benchmark-Phases" class="common-anchor-header">Две фазы тестирования</h3><p>VDBBench разделяет тестирование на две важнейшие фазы:</p>
<ol>
<li><strong>Последовательный тест</strong></li>
</ol>
<p>Это однопроцессный прогон 1 000 запросов. На этом этапе устанавливается базовый уровень идеальной производительности и точности, а также формируются отчеты <code translate="no">serial_latency_p99</code> и recall.</p>
<ol start="2">
<li><strong>Тестирование параллелизма</strong></li>
</ol>
<p>Эта фаза имитирует производственную среду при устойчивой нагрузке.</p>
<ul>
<li><p><strong>Реалистичное моделирование клиента</strong>: Каждый тестовый процесс работает независимо со своим собственным соединением и набором запросов. Это позволяет избежать вмешательства общего состояния (например, кэша), которое может исказить результаты.</p></li>
<li><p><strong>Синхронизированный запуск</strong>: Все процессы запускаются одновременно, что гарантирует, что измеренный QPS точно отражает заявленный уровень параллелизма.</p></li>
</ul>
<p>Эти тщательно структурированные методы гарантируют, что значения <code translate="no">max_qps</code> и <code translate="no">conc_latency_p99</code>, сообщаемые VDBBench, являются <strong>точными и актуальными для производства</strong>, предоставляя значимые сведения для планирования производственных мощностей и проектирования систем.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Latency_of_Milvus_16c64g_standalone_at_Varying_Concurrency_Levels_Cohere_1_M_Test_7f2294e87a.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: QPS и задержка Milvus-16c64g-standalone при различных уровнях параллелизма (тест Cohere 1M). В этом тесте Milvus изначально недоиспользуется до</em> <strong><em>уровня параллелизма 20</em></strong><em>, увеличение параллелизма улучшает использование системы и приводит к повышению QPS. После</em> <strong><em>20-го уровня параллелизма</em></strong><em> система достигает полной нагрузки: дальнейшее увеличение параллелизма уже не улучшает пропускную способность, а задержка возрастает из-за задержек в очередях.</em></p>
<h2 id="Beyond-Searching-Static-Data-The-Real-Production-Scenarios" class="common-anchor-header">За пределами поиска статических данных: Реальные производственные сценарии<button data-href="#Beyond-Searching-Static-Data-The-Real-Production-Scenarios" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Насколько нам известно, VDBBench - единственный бенчмарк, который тестирует векторные базы данных в полном спектре критически важных производственных сценариев, включая статический сбор, фильтрацию и потоковую передачу данных.</p>
<h3 id="Static-Collection" class="common-anchor-header">Статическая коллекция</h3><p>В отличие от других бенчмарков, которые спешат с тестированием, VDBBench сначала убеждается, что каждая база данных полностью оптимизировала свои индексы - критически важное условие производства, которым многие бенчмарки часто пренебрегают. Таким образом, вы получаете полную картину:</p>
<ul>
<li><p>Время поступления данных</p></li>
<li><p>Время индексирования (время, затрачиваемое на создание оптимизированного индекса, что существенно влияет на производительность поиска)</p></li>
<li><p>Производительность поиска по полностью оптимизированным индексам в условиях последовательного и параллельного поиска</p></li>
</ul>
<h3 id="Filtering" class="common-anchor-header">Фильтрация</h3><p>Векторный поиск в производстве редко происходит изолированно. В реальных приложениях векторное сходство сочетается с фильтрацией метаданных ("найти обувь, похожую на эту фотографию, но стоимостью менее 100 долларов"). Такой фильтрованный векторный поиск создает уникальные проблемы:</p>
<ul>
<li><p><strong>Сложность фильтра</strong>: Большее количество скалярных столбцов и логических условий повышают вычислительные требования.</p></li>
<li><p><strong>Избирательность фильтра</strong>: <a href="https://milvus.io/blog/how-to-filter-efficiently-without-killing-recall.md">Наш производственный опыт</a> показывает, что это скрытый убийца производительности - скорость запросов может колебаться на порядки в зависимости от того, насколько избирательными являются фильтры.</p></li>
</ul>
<p>VDBBench систематически оценивает производительность фильтров на разных уровнях селективности (от 50% до 99,9%), предоставляя полный профиль того, как базы данных справляются с этой критической производственной моделью.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Recall_of_Milvus_and_Open_Search_Across_Different_Filter_Selectivity_Levels_Cohere_1_M_Test_4b5df2244d.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: QPS и Recall Milvus и OpenSearch при различных уровнях селективности фильтров (тест Cohere 1M). Ось X представляет собой процент отфильтрованных данных. Как видно, Milvus сохраняет стабильно высокий уровень запоминания на всех уровнях избирательности фильтра, в то время как OpenSearch демонстрирует нестабильную производительность, при этом запоминание значительно колеблется при различных условиях фильтрации.</em></p>
<h3 id="Streaming" class="common-anchor-header">Потоковая передача</h3><p>Производственные системы редко могут похвастаться статичностью данных. Во время поиска в них постоянно поступает новая информация - сценарий, при котором многие впечатляющие базы данных терпят крах.</p>
<p>Уникальный тестовый пример VDBBench для потоковых систем исследует производительность поиска при вставке, измеряя:</p>
<ol>
<li><p><strong>Влияние растущего объема данных</strong>: Как производительность поиска изменяется с увеличением объема данных.</p></li>
<li><p><strong>Влияние нагрузки при записи</strong>: как одновременная запись влияет на задержку и пропускную способность поиска, поскольку запись также потребляет ресурсы процессора или памяти в системе.</p></li>
</ol>
<p>Потоковые сценарии представляют собой комплексный стресс-тест для любой векторной базы данных. Но создание <em>справедливого</em> бенчмарка для этого не является тривиальной задачей. Недостаточно описать поведение одной системы - нам нужна последовательная модель оценки, позволяющая <strong>сравнивать</strong> различные базы данных между собой.</p>
<p>Опираясь на наш опыт помощи предприятиям в реальных развертываниях, мы разработали структурированный, повторяемый подход. С помощью VDBBench:</p>
<ul>
<li><p>Вы <strong>задаете фиксированную скорость внедрения</strong>, которая отражает целевую производственную нагрузку.</p></li>
<li><p>Затем VDBBench применяет <strong>идентичное давление нагрузки</strong> на все системы, обеспечивая прямое сравнение результатов производительности.</p></li>
</ul>
<p>Например, набор данных Cohere 10 М и скорость ввода 500 строк в секунду:</p>
<ul>
<li><p>VDBBench запускает 5 параллельных процессов производителей, каждый из которых вставляет 100 строк в секунду.</p></li>
<li><p>После обработки каждых 10 % данных VDBBench запускает цикл тестирования поиска в последовательном и параллельном режимах.</p></li>
<li><p>После каждого этапа фиксируются такие показатели, как задержка, QPS и отзыв.</p></li>
</ul>
<p>Эта контролируемая методология показывает, как производительность каждой системы изменяется с течением времени и в условиях реального рабочего стресса, что дает вам понимание, необходимое для принятия решений по масштабированию инфраструктуры.</p>
<p>
  <span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/igure_QPS_and_Recall_of_Pinecone_vs_Elasticsearch_in_the_Cohere_10_M_Streaming_Test_500_rows_s_Ingestion_Rate_548fc02f24.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: QPS и Recall Pinecone в сравнении с Elasticsearch в потоковом тесте Cohere 10M (скорость переполнения 500 строк/с). Pinecone сохранил более высокие показатели QPS и recall, показав значительное улучшение QPS после вставки 100% данных.</em></p>
<p>Но это еще не конец истории. VDBBench идет еще дальше, поддерживая дополнительный шаг оптимизации, позволяя пользователям сравнивать производительность потокового поиска до и после оптимизации индекса. Он также отслеживает и сообщает о фактическом времени, затраченном на каждый этап, предлагая более глубокое понимание эффективности системы и ее поведения в производственных условиях.</p>
<p><span class="img-wrapper">
    <img translate="no" src="https://assets.zilliz.com/Figure_QPS_and_Recall_of_Pinecone_vs_Elasticsearch_in_the_Cohere_10_M_Streaming_Test_After_Optimization_500_rows_s_Ingestion_Rate_d249d290bb.png" alt="" class="doc-image" id="" />
    <span></span>
  </span>
</p>
<p><em>Рисунок: QPS и Recall Pinecone против Elasticsearch в потоковом тесте Cohere 10M после оптимизации (скорость переполнения 500 строк/с)</em></p>
<p>Как видно из диаграммы, ElasticSearch превзошел Pinecone по показателю QPS после оптимизации индекса. Чудо? Не совсем. На правой диаграмме показана вся история: когда ось x отражает реальное прошедшее время, становится ясно, что ElasticSearch потребовалось значительно больше времени, чтобы достичь такой производительности. А в производстве эта задержка имеет значение. Это сравнение показывает ключевой компромисс: пиковая пропускная способность против времени обслуживания.</p>
<h2 id="Choose-Your-Vector-Database-with-Confidence" class="common-anchor-header">Выбирайте свою векторную базу данных с уверенностью<button data-href="#Choose-Your-Vector-Database-with-Confidence" class="anchor-icon" translate="no">
      <svg translate="no"
        aria-hidden="true"
        focusable="false"
        height="20"
        version="1.1"
        viewBox="0 0 16 16"
        width="16"
      >
        <path
          fill="#0092E4"
          fill-rule="evenodd"
          d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"
        ></path>
      </svg>
    </button></h2><p>Разрыв между результатами бенчмарков и реальной производительностью не должен быть игрой в угадайку. VDBBench предоставляет возможность оценить векторные базы данных в реалистичных, похожих на производственные условиях, включая непрерывное поступление данных, фильтрацию метаданных и потоковые рабочие нагрузки.</p>
<p>Если вы планируете развернуть векторную базу данных в производстве, стоит понять, как она работает за пределами идеализированных лабораторных тестов. VDBBench с открытым исходным кодом, прозрачный и разработанный для поддержки значимых сравнений между яблоками.</p>
<p>Попробуйте VDBBench на своих собственных рабочих нагрузках уже сегодня и посмотрите, как различные системы работают на практике: <a href="https://github.com/zilliztech/VectorDBBench">https://github.com/zilliztech/VectorDBBench.</a></p>
<p>У вас есть вопросы или вы хотите поделиться своими результатами? Присоединяйтесь к обсуждению на<a href="https://github.com/zilliztech/VectorDBBench"> GitHub</a> или общайтесь с нашим сообществом в <a href="https://discord.com/invite/FG6hMJStWu">Discord</a>. Мы будем рады услышать ваши мнения.</p>
